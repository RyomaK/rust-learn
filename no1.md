## 所有権

```rust
let v = 1;
//ゼロ抽象化
//let v = vec!{1,2,3};
//ヒープにポインタ，スタックにオブジェクト
//所有権がv2に行くため,v2とvが同じオブジェクトをさす(ムーブして)ため，vを使えなくなる
// v=1はプリミティブのため完全コピー
let v2 = v;

println!("v is: {}", v);

```

```rust
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // v1とv2についての作業を行う

    // 答えを返す
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);

// ここではv1とv2が使える!
/*
but　foo関数では変更できない=>イミュータブルである
let  &mutでは変更できる
*/

```
### 借用のルール
最初に、借用は全て所有者のスコープより長く存続してはなりません。 次に、次の2種類の借用のどちらか1つを持つことはありますが、両方を同時に持つことはありません。
- リソースに対する1つ以上の参照（ &T ）
- ただ1つのミュータブルな参照（ &mut T ）

```rust
let mut x = 5;

let y = &mut x;    // -+ xの&mut借用がここから始まる
                   //  |
*y += 1;           //  |
                   //  |
println!("{}", x); // -+ - ここでxを借用しようとする
                   // -+ xの&mut借用がここで終わる
```
スコープは衝突します。 y がスコープにある間は、 &x を作ることができません。
これを

```
let mut x = 5;

{
    let y = &mut x; // -+ &mut借用がここから始まる
    *y += 1;        //  |
}                   // -+ ... そしてここで終わる

println!("{}", x);  // <- ここでxを借用しようとする
```
これにすると見れる

### ライフタイム

- 関数の引数の中の省略された各ライフタイムは互いに異なるライフタイムパラメータになる
- もし入力ライフタイムが1つだけならば、省略されたかどうかにかかわらず、そのライフタイムはその関数の戻り値の中の省略されたライフタイム全てに割り当てられる
- もし入力ライフタイムが複数あるが、その1つが &self 又は &mut self であれば、 self のライフタイムは省略された出力ライフタイム全てに割り当てられる

```rust
fn print(s: &str); // 省略された形
fn print<'a>(s: &'a str); // 展開した形

fn debug(lvl: u32, s: &str); // 省略された形
fn debug<'a>(lvl: u32, s: &'a str); // 展開された形

// 前述の例では`lvl`はライフタイムを必要としません。なぜなら、それは参照（`&`）
// ではないからです。（参照を含む`struct`のような）参照に関係するものだけがライ
// フタイムを必要とします。

fn substr(s: &str, until: u32) -> &str; // 省略された形
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // 展開された形

fn get_str() -> &str; // 不正。入力がない

fn frob(s: &str, t: &str) -> &str; // 不正。入力が2つある
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // 展開された形。出力ライフタイムが決まらない

fn get_mut(&mut self) -> &mut T; // 省略された形
fn get_mut<'a>(&'a mut self) -> &'a mut T; // 展開された形

fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command; // 省略された形
fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // 展開された形

fn new(buf: &mut [u8]) -> BufWriter; // 省略された形
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // 展開された形

```

## ゼロコスト抽象化
```fn(x: i32) -> i32{}```

return を明示しない時は，一番最後の行が返されるが，
```;``` は入れないk


